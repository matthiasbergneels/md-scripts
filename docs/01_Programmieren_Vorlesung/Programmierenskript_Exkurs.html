<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <title>Programmieren - Exkurse</title>
    <link rel="shortcut icon" href="./../favicon.ico" />
    <link rel="stylesheet" href="./../dist/reset.css" />
    <link rel="stylesheet" href="./../dist/reveal.css" />
    <link rel="stylesheet" href="./../dist/theme/simple.css" id="theme" />
    <link rel="stylesheet" href="./../css/highlight/base16/zenburn.css" />

    <link rel="stylesheet" href="./../_assets/scripts/_assets/style.css" />
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section data-markdown data-separator="\r?\n---\r?\n" data-separator-vertical="\r?\n----\r?\n">
          <textarea data-template>
            

# Programmieren - Exkurse
### Matthias Berg-Neels

> [Download Skript](../pdfdownloads/ProgrammierenSkript_Exkurs.pdf)

----
## Inhalt

* Naming conventions
* Implizite Typisierung mittels ```var```
* Unit Tests
* Innere Klassen
* Entwurfsmuster (Design Patterns)
* (Die Evolution von Java)
* (Optionals)
* (Programming Principals)

---
# Naming conventions
> Naming conventions sind, in (gro√üen) Projekten / Firmen, Bestandteil der "Code Style Guidelines". Firmen bzw. Community basiert gibt es unterschiedliche Code Style Guidelines nach denen man sich richten kann. Die folgenden Konventionen basieren auf den [Google Style Guidelines f√ºr Java](https://google.github.io/styleguide/javaguide.html#s5-naming).

----
## Allgemeine Regeln f√ºr Bezeichner und Namen (1/2)

**Regeln**
* erlaubte Zeichen
  * Buchstaben (Case sensitive): a, b, c, ..., x, y, z, A, B, ..., Y, Z
    * Landespezifische Zeichen sind erlaubt (z.B. √§, √º, √∂) - sollten aber vermieden werden! (Stichwort: Kompatibilit√§t zwischen Rechnern - betrifft NUR Quellcode, nicht den Bytecode!)
  * Unterstrich: _
  * Dollarzeichen: $
  * Zahlen: 0, 1, 2, ..., 9
* nicht erlaubte Zeichensatz
  * Sonderzeichen

----
## Allgemeine Regeln f√ºr Bezeichner und Namen (2/2)
**weitere Regeln**
* keine Leerzeichen
* d√ºrfen nicht mit Zahlen beginnen
* d√ºrfen nicht gleich mit reservierten Schl√ºsselw√∂rtern sein

**Empfehlungen**
<div>

* sprechende Namen -> man kann beim Lesen verstehen was eine Variable, Klasse, Methode f√ºr eine Aufgabe hat.
* **Merksatz**: Wenn man einen Namen lesen kann ohne "grammatikalische" Bauchschmerzen zu bekommen, ist es die richtige Richtung.
* **Anmerkung**: Namen sollten immer die tats√§chliche Funktion einer Entit√§t widerspiegeln, daher stehen sie in hoher Abh√§ngigkeit zum Quellcode. Eine Variable mit dem Namen "WindowCount" (vom Typ Boolean), eine Methode "saveToDatabase" (die nichts Speichert) oder eine Klasse "Student" (die Funktionen einer Vorlesung enth√§lt) sollten namentlich noch einmal √ºberdacht werden, auch wenn diese sich "rein vom Namen" korrekt lesen.

</div><!-- .element style="font-size: 0.8em;" -->

----
## Packagenamen

**Guideline**
* klein geschrieben

```Java
de.mbn.myapp.lecture
lecture.objectorientation.trainstation
```

----

## Klassennamen

**Guideline**
* beginnen mit einem Gro√übuchstaben
* UpperCamelCase - beginnen mit Gro√übuchstaben und jedes neue Wort beginnt mit einem Gro√übuchstaben
* Zusatz: Der Dateiname muss sich nach dem Namen der Hauptklasse (first level) in der Datei richten

```Java
Car
Student
TrainDriver
```

----

## Variablen / Attribute

**Guideline**
* lowerCamelCase - beginnen mit einem Kleinbuchstaben und jedes neue Wort beginnt mit einem Gro√übuchstaben

```Java
familyName
children
studentId
```

----

## Konstanten

**Guideline**
* UPPER_CASE - werden vollst√§ndig mit Gro√übuchstaben geschrieben, neue W√∂rter werden durch Unterstrich getrennt

```Java
ALLOWED_COLOR_RED
MEANING_OF_LIFE
```
----
## Methoden

**Guideline**
* lowerCamelCase - beginnen mit einem Kleinbuchstaben und jedes neue Wort beginnt mit einem Gro√übuchstaben
* beginnen mit einem Verb (bzw enthalten mindestens ein Verb)
  * eine Methode "spiegelt" eine T√§tigkeit, Geschehen, Vorgang wieder --> es passiert etwas

```Java
accelerate();
persistData();
```

**Getter- / Setter**
* Attributname wird mit get bzw. set vorangestellt in lowerCamelCase

```Java
setFamilyName();
getFamilyName();
```

----

## Spezialfall: Boolean Attribute / Getter-Methoden
* sprechende Definition von Boolean-Attribute
  * z.B. enabled, isTired (VS tired), hasFlatRoof (VS flatRoof), canFly (VS fly), ...
* Boolean Getter-Methoden werden nicht mit get, sondern mit dem passenden Verb (is, has, can) gebildet
  * isEnabled(), isTired(), hasFlatRoof(), canFly()
* anh√§ngig vom Attributnamen k√∂nnen in diesem Fall die Setter-Namen doch komisch wirken
  * setEnabled, setIsTired (VS setTired), setHasFlatRoof (VS setFlatRoof), setCanFly (VS setFly)


----

## Ein Beispiel aus dem echten Leben (/ produktiven Code)

<div>

```Java

package com.sap.iot.rules.ruleprocessorstream.cache.repository;

import // ...

public class ThingModelBasedDataObjectRepository extends HashOperationsRepository<ThingModelBasedDataObject> {

    private static final String KEY_PREFIX = "do_by_rsid_tt_ps";

    private static final String NAME = "name";
    private static final String TYPE = "type";
    private static final String IS_RESULT = "isResult";
    private static final String THING_TYPE = "thingType";
    private static final String PROPERTY_SET = "propertySet";
    private static final String PROPERTY_SET_TYPE = "propertySetType";
    private static final String SENSITIVITY_LEVEL = "sensitivityLevel";
    private static final String LIST_SIZE_SUFFIX = "size";
    private static final String USED_ATTRIBUTES_PREFIX = "usedAttributes.";
    private static final String WILDCARD = "*";

    public ThingModelBasedDataObjectRepository(@Qualifier("ruleCache") RedisTemplate<String, String> redisTemplate, TenantContext tenantContext) {
        // ...
    }

    @Override
    public String getUniqueCachingKeyPrefix() {
        // ...
    }

    @Override
    public void save(@NotBlank String ermRuleServiceId, @Valid ThingModelBasedDataObject dataObject) {
        // ...
    }

    public Optional<ThingModelBasedDataObject> find(@NotBlank String ermRuleServiceId, String thingType, String propertySet) {
        // ...
    }

    public List<ThingModelBasedDataObject> findAll(@NotBlank String ermRuleServiceId, String thingType) {
        // ...
    }

    public Optional<ThingModelBasedDataObject> find(@NotBlank String ermRuleServiceId, String propertySetType) {
        // ...
    }

    public Boolean delete(@NotBlank String ermRuleServiceId, String thingType, String propertySet, String propertySetType) {
        // ...
    }

    @Override
    public long deleteAll(@NotBlank String ermRuleServiceId) {
        // ...
    }

    @Override
    protected Map<String, String> serialize(ThingModelBasedDataObject dataObject) {
        // ...
    }

    @Override
    protected ThingModelBasedDataObject deserialize(Map<String, String> map) {
        // ...
    }

    protected String getCachingKeySuffix(@NotBlank String ermRuleServiceId, String thingType, String propertySet, String propertySetType) {
        // ...
    }

}
```
</div><!-- .element style="font-size: 0.5em;" -->

---
# implizite Typisierung mittels ```var```

> Ermittlung des Datentyps einer Variable ohne spezifische Angabe des Typs mittels der Initialisierung - Schl√ºsselwort ```var``` (seit Java 10) <sub>some evil stuff</sub>

----
## Verwendung

**Voraussetzung**
* Deklaration mit ```var``` UND sofortiger Initialisierung der Variable.

**Beispiele**
```Java
var numberA = 10;                     // numberA wird zu Integer Variable deklariert
var numberB = 42.0;                   // numberB wird zu Double Variable deklariert
var textA = "Herzlich Willkommen";    // textA wird zu String Variable deklariert
var myAnimal = new Dog(...);          // myAnimal wird zu Dog Variable deklariert

var test;                             // Compiler Fehler!

int numberC = 100;

var numberD = numberC;                // numberD wird zu Integer Variable deklariert
```

**Besser lesbarer (k√ºrzerer) Code** durch Vermeidung von Redundanzen
<div>

```Java
// vorher:
ThingModelBasedDataObjectRepository myThingModelRepo =
      new ThingModelBasedDataObjectRepository(myChacheTemplate, customerTenant);

// neu:
var myThingModelRepo = new ThingModelBasedDataObjectRepository(myChacheTemplate, customerTenant);
```

</div><!-- .element style="font-size: 0.85em;" -->

----

## ABER...

Falsch eingesetzt, wird der Code unverst√§ndlicher / komplizierter zu lesen:

```Java
var somethingOne = (farm.hasAnimal()) ? new Dog(...) : "Kein Tier";
var somethingTwo = ("Ergebnis ist " + (numberA + numberB * 50.1)).length() / (double)10;
var somethingThree = Something.returnSomething();
// ...
```

---
# Unit Testing

> Unit Testing in Java mit JUnit5.

----
## Einordnung von Unit Tests

<div align="center">
<img src="img/0x_junit_02testpyramide.svg" width=60% /><!-- .element style="border: 0px; box-shadow: 0 0 0 0; align="center"" -->
</div>

----
## JUnit5 - Basis Annotationen

<div>

| Annotation | Beschreibung | 
|:----------:|:-------------|
| ```@Test``` | kennzeichnet eine Methode als Test | 
| ```@Tag("<tag>")``` | definiert einen Tag zur Filterung von Tests | 
| ```@BeforeEach``` | kennzeichnet eine Methode die **vor jedem** Test l√§uft (JUnit4 --> ```@Before```) | 
| ```@AfterEach``` | kennzeichnet eine Methode die **nach jedem** Test l√§uft (JUnit4 --> ```@After```) | 
| ```@BeforeAll``` | kennzeichnet eine Methode die **einmal vor allen** Tests l√§uft (JUnit4 --> ```@BeforeClass```) | 
| ```@AfterAll``` | kennzeichnet eine Methode die **einmal nach allen** Tests l√§uft (JUnit4 --> ```@AfterClass```) | 

</div><!-- .element style="font-size: 0.7em;" -->

----

## Assertion

<div>

* Zusicherung / Sicherstellung / Assertion (lat. Aussage / Behauptung)
  * Definition einer Erwartungshaltung zum Vergleich gegen den tats√§chlichen Zustand
* JUnit Tests:
  * Klasse: ```Assertions``` (```org.junit.jupiter.api.Assertions```)
  * statische Methoden zur Definition eines erwartenden Ergebnisses (expected) zum Vergleich mit dem tats√§chlichen Ergebnis (actual)
  * √ºberladene Methoden mit zus√§tzlichem Parameter ```Message``` f√ºr eigene Meldungen
  * automatische Validierung der "Behauptung" durch das JUnit Test-Framework
  * beliebt als statischer Import zur direkten Nutzung der Methoden:

  ```Java
  import static org.junit.jupiter.api.Assertions.*;
  ```

  * Beispiele:

  ```Java
    Assertions.assertEquals(<expected>, <actual>[, <Message>]);
    Assertions.assertNotEquals(<expected>, <actual>[, <Message>]);
    Assertions.assertTrue(<actual>[, <Message>]);
    Assertions.assertFalse(<actual>[, <Message>]);
    Assertions.assertTimeout(<expected Duration>, <Executable>[, <Message>]);
    Assertions.assertThrows(<expected Exception-Class>, <Executable>[, <Message>]);
    ```

</div><!-- .element style="font-size: 0.8em;" -->

----
## JUnit5 - neue Annotationen

<div>

| Annotation | Beschreibung | 
|:----------:|:-------------|
|¬†```@DisplayName("descriptive name")``` | definiert den Anzeigename f√ºr den jeweiligen Test / die Testklasse¬†|
|¬†```@Nested``` | markiert eine innere (geschachtelte) Testklasse -> Strukturierung |
|¬†```@RepeatedTest(count)``` | sich wiederholender Testfall |
|¬†```@ParameterizedTest``` | Testfall Parametrisierung -> siehe n√§chste Slide |

</div><!-- .element style="font-size: 0.7em;" -->

----
## ```@ParameterizedTest```

* Separierung von Test-Code und Testfall
* verschiedene Quellen f√ºr Testf√§lle
  * ```@ValueSource```
  * ```@EmptySource``` / ```@NullSource``` / ```@NullAndEmptySource```
  * ```@EnumSource```
  * ```@CsvSource``` / ```@CsvFileSource```
  * ```@MethodSource```

----
## JUnit5 - N√ºtzliches

### Testen von Ausnahmen
```Java
Exception assertThrows(ExceptionClass, Executable)
```

### Testen von mehrer Annotationen auf einmal
```Java
void assertAll(Executable ...);
```

### Testen der Laufzeit
```Java
void assertTimeout(Duration, Executable);
```

----
## Beispiel: Einfache Test-Klasse
```Java
import excercises.exkurs.junit.Calculator;
import org.junit.jupiter.api.*;

class CalculatorTest {

    Calculator myCalculator;
    double result = 0;

    @BeforeEach
    void setUp() {
        myCalculator = new Calculator();
        result = 0;
    }

    @Test
    @DisplayName("adding two numbers")
    void add() {
        result = myCalculator.add(5.0, 10.0);
        Assertions.assertEquals(15.0, result);
    }
}

```

----
## F.I.R.S.T. Principal
* **Fast**: Die Testausf√ºhrung soll schnell sein, damit man sie m√∂glichst oft ausf√ºhren kann. Je √∂fter man die Tests ausf√ºhrt, desto schneller bemerkt man Fehler und desto einfacher ist es, diese zu beheben.
* **Independent**: Unit-Tests sind unabh√§ngig voneinander, damit man sie in beliebiger Reihenfolge, parallel oder einzeln ausf√ºhren kann.
* **Repeatable**: F√ºhrt man einen Unit-Test mehrfach aus, muss er immer das gleiche Ergebnis liefern.
* **Self-Validating**: Ein Unit-Test soll entweder fehlschlagen oder gut gehen. Diese Entscheidung muss der Test treffen und als Ergebnis liefern. Es d√ºrfen keine manuellen Pr√ºfungen n√∂tig sein.
* **Timely**: Man soll Unit-Tests vor der Entwicklung des Produktivcodes schreiben.

---

# Innere Klassen

> von inneren Klassen hin zu Lambda-Funktionen

----

## Arten von inneren Klassen

<div>

* Innere Top-Level Klasse
  * Geschachtelte statische Klasse innerhalb einer anderen Klasse mit Bezeichner (Klassenname)
  * k√∂nnen innerhalb und au√üerhalb (abh√§ngig von der Sichtbarkeit) der Klasse verwendet werden
* Innere Element Klasse
  * Geschachtelte Klasse innerhalb einer anderen Klasse mit Bezeichner (Klassenname)
  * k√∂nnen innerhalb und au√üerhalb (abh√§ngig von der Sichtbarkeit) der Klasse verwendet werden
    * nur im Kontext eines Objekts der √§u√üeren Klasse
* Innere lokale Klasse
  * Geschachtelte Klasse innerhalb einer Methode mit Bezeichner (Klassenname)
  * k√∂nnen nur innerhalb der Methode (Scope) genutzt werden
* Innere anonyme Klasse
  * geschachtelte Klasse innerhalb einer anderen Klasse / Methode **ohne** Bezeichner
  * werden direkt einer Referenz zugwiesen
  * basieren immer auf einer Klasse (erweitern) oder einem Interface (implementieren)
</div><!-- .element style="font-size: 0.8em;" -->

----
## Innere Top-Level-Klasse

<div>

```Java
package main.inner.toplevelclass;

public class OuterClass {

    // Innerhalnb einer anderen Klasse definierte Top-Level Klasse
    public static class InnerTopLevelClass{
        void print(String printText){
            System.out.println(this.getClass().getName() + " " + printText);
        }
    }

    private static void printFromInnerTopLevelClass(String printText) {
        OuterClass.InnerTopLevelClass myInnerTopLevelClass = new OuterClass.InnerTopLevelClass();
        myInnerTopLevelClass.print(printText);
    }

    public static void main(String[] args) {
        OuterClass myClass = new OuterClass();

        System.out.println("OuterClass: " + myClass.getClass().getName());
        OuterClass.printFromInnerTopLevelClass("Inner Top-Level Class: HelloWorld");
    }
}
```

</div><!-- .element style="font-size: 0.9em;" -->

----
## Innere Element-Klasse

<div>

```Java

package main.inner.elementclass;

public class OuterClass {

    // Innerhalb einer andere Klasse definierte Element Klasse
    public class InnerElementClass {
        void print(String printText){
            System.out.println(this.getClass().getName() + " " + printText);
        }
    }

    void printFromInnerElementClass(String printText){
        OuterClass.InnerElementClass myInnerElementClass = this.new InnerElementClass();

        myInnerElementClass.print(printText);
    }

    public static void main(String[] args) {
        OuterClass myClass = new OuterClass();

        System.out.println("OuterClass: " + myClass.getClass().getName());
        myClass.printFromInnerElementClass("Inner Element Class: HelloWorld");
    }
}
```

</div><!-- .element style="font-size: 0.9em;" -->

----
## Innere lokale Klasse

<div>

```Java
package main.inner.local;

public class OuterClass {

    void printFromLocalInnerClass(String printText){
        // innerhalb einer Methode (Scope) definierte Klasse
        class LocalInnerClass{
            void print(String printText){
                System.out.println(this.getClass().getName() + " " + printText);
            }
        }

        LocalInnerClass myLocalInnerClass = new LocalInnerClass();

        myLocalInnerClass.print(printText);
    }

    public static void main(String[] args) {
        OuterClass myClass = new OuterClass();

        System.out.println("OuterClass: " + myClass.getClass().getName());
        myClass.printFromLocalInnerClass("local inner Class: HelloWorld");
    }
}
```

</div><!-- .element style="font-size: 0.9em;" -->

----
## Innere anonyme Klasse

<div>

```Java
package main.inner.anonym;

public class OuterClass {

    private static interface Printable{
        void print(String printText);
    }

    void printFromAnonymousInnerClass(String printText) {
        // ohne eigenen Bezeichner definiert (kann nicht wiederverwendet werden)
        // erweitert eine bestehende Klasse oder implementiert ein Interface
        OuterClass.Printable myAnonymousInnerClass = new OuterClass.Printable() {
            @Override
            public void print(String printText) {
                System.out.println(this.getClass().getName() + " " + printText);
            }
        };

        myAnonymousInnerClass.print(printText);
    }

    public static void main(String[] args) {
        OuterClass myClass = new OuterClass();

        System.out.println("OuterClass: " + myClass.getClass().getName());
        myClass.printFromAnonymousInnerClass("Inner anonymous Class: HelloWorld");
    }
}
```
</div><!-- .element style="font-size: 0.75em;" -->

----
## Lambda Funktionen (anonyme Funktionen)

<div>

* seit Java 8
* reine Funktionen ohne eigene Klasse
* Definition: ```()->{}```
* implementieren ein funktionales Interface (Interface mit **einer** Methode, **ohne default** Implementierung)
  * ersetzen (unter dieser Voraussetzung) anonyme Klassen
* haben Zugriff auf den umliegenden Kontext (finale / effektiv finale Variablen)
  * in diesem Zusammenhang auch als "Closure" bezeichnet
* verk√ºrzte Schreibweise durch Herleitung der Informationen aus Interface-Definition
* werden an eine Referenz √ºbergeben (direkt oder indirekt)
</div><!-- .element style="font-size: 0.8em;" -->

```Java
Interface1 lambda1 = parameter -> Anweisung;
Interface2 lambda2 = (parameter1, parameter2) -> Anweisung;
Interface3 lambda3 = () -> {
  Anweisung1;
  Anweisung2;
  Anweisung3;
}

```

----
## Lambda Funktion

<div>

```Java
package main.lambda;

public class OuterClass {

    private static interface Printable{
        void print(String printText);
    }

    void printFromLambdaFunction(String printText) {
        // Lambda Funktionen sind "reine Funktionen" ohne Klasse
        // nutzen immer ein funktionales Interface (nur eine Methode)
        // zur Implementierung
        OuterClass.Printable myLambdaPrintFunction = (lambdaPrintText) -> {
            System.out.println(this.getClass().getName() + " " + lambdaPrintText);
        };

        myLambdaPrintFunction.print(printText);
    }

    public static void main(String[] args) {
        OuterClass myClass = new OuterClass();

        System.out.println("OuterClass: " + myClass.getClass().getName());
        myClass.printFromLambdaFunction("Lambda Function: HelloWorld");
    }
}
```
</div><!-- .element style="font-size: 0.8em;" -->


---
# Streams

----
## Streams (<a target=_blank href=https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/io/package-summary.html>```java.io```</a>) VS Streams (<a target=_blank href=https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/util/stream/package-summary.html>```java.util.stream```</a>)

<div>

Stream - Grundkonzept
* √ºbertragen von Elementen (Daten / Objekten) zwischen einer Quelle und einem Ziel

Stream (```java.util.stream```)
* einfache (besser lesbare) Modifikation von Objekt(-Str√∂men)
  * Ersatz (funktionales Paradigma) f√ºr sequentielle Abarbeitung wie z.B. Schleifen
* Erweiterung des Collection Framework
* Quelle von Interface Collection, Ziel von Interface Collection, einfache Datentypen, etc (abh√§ngig von Funktion)

Stream (```java.io```)
* √ºbertragen von Daten zu bzw. von externen Ressourcen
* I/O --> Input / Output
* Beispiele
  * lesen aus Dateien
  * Ausgabe auf der Konsole
  * senden von Daten √ºber das Netzwerk

</div><!-- .element style="font-size: 0.6em;" -->

----
## Konzept

* Aufbau
    * Erzeugende-Operationen
    * Zwischen-Operationen
    * End-Operationen 
* Tr√§gheit (Laziness)
* Nicht Inteferenz

----
## Zwischen-Operationen

* ["üçÜ", "üçÖ", "ü´õ"].filter("üçÜ") --> 

---
# Entwurfsmuster (Design Patterns)

----
## Entwurfsmuster (Design Patterns) in der Software-Entwicklung

* L√∂sungsschablonen f√ºr wiederkehrende Probleme im Software-Entwurf
* zur Verbesserung der Softwarearchitektur, Strukturierung des Code und bessere Lesbarkeit
* verschiedene Arten: Erzeugungs-, Struktur- und Verhaltensmuster
* stellen keine starren Regeln, sondern flexible Richtlinien, die an die jeweilige Situation angepasst werden k√∂nnen

----
## Erzeugungs-Muster (Creational Patterns)

* Erzeugung von Objekten
* entkoppeln die Konstruktion eines Objekts von seiner Repr√§sentation
* erm√∂glichen z.B. eine flexible Auswahl der konkreten Klassen zur Laufzeit
* Beispiele: factory method, Factory, Singleton, Builder

----
## Struktur-Muster (Structural Patterns)

* erleichtern den Software Entwurf und die Strukturierung durch herstellen von Beziehungen zwischen Entit√§ten
* nutzen Abstraktion um komplexe, kombinierte Objekte zu erzeugen und die einzelnen Bestandteile und Strukturen flexibel zu halten
* Beispiele: Facade (Einfache Schnittstelle f√ºr komplexe Objekte), Adapter (Verbinden von inkompatiblen Schnittstellen) Kompositum, das eine Hierarchie von Objekten bildet, die als Einheit behandelt werden k√∂nnen


----
## Verhaltens-Muster (Behavioral Patterns)

* erleichtern den Software Entwurf und die Strukturierung durch herstellen von Beziehungen zwischen Entit√§ten
* nutzen Abstraktion 
Sie erm√∂glichen eine Abstraktion, die mit anderen L√∂sungsans√§tzen kommunizieren kann2
Sie k√∂nnen in verschiedene Arten eingeteilt werden, wie zum Beispiel Adapter, Br√ºcke, Dekorierer, Fassade, Fliegengewicht, Kompositum oder Proxy3
Beispiele f√ºr Strukturmuster sind: Fassade, die eine vereinfachte Schnittstelle zu einem komplexen System bietet4; Adapter, der zwei inkompatible Schnittstellen verbindet; Kompositum, das eine Hierarchie von Objekten bildet, die als Einheit behandelt werden k√∂nnen

---
# Optionals

> TODO... :-)


--- 
# Programming Principals

> DRY, KISS, ... TODO... :-)

----
## Principal Collection
* KISS
* DRY
* FIRST

          </textarea>
        </section>
      </div>
    </div>

    <script src="./../dist/reveal.js"></script>

    <script src="./../mermaid/dist/mermaid.min.js"></script>

    <script src="./../plugin/markdown/markdown.js"></script>
    <script src="./../plugin/highlight/highlight.js"></script>
    <script src="./../plugin/zoom/zoom.js"></script>
    <script src="./../plugin/notes/notes.js"></script>
    <script src="./../plugin/math/math.js"></script>
    <script>
      function extend() {
        var target = {};
        for (var i = 0; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (source.hasOwnProperty(key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }

      // default options to init reveal.js
      var defaultOptions = {
        controls: true,
        progress: true,
        history: true,
        center: true,
        transition: 'default', // none/fade/slide/convex/concave/zoom
        slideNumber: true,
        highlight: {
          highlightOnLoad: false
        },
        plugins: [
          RevealMarkdown,
          RevealHighlight,
          RevealZoom,
          RevealNotes,
          RevealMath
        ]
      };

      // options from URL query string
      var queryOptions = Reveal().getQueryHash() || {};

      var options = extend(defaultOptions, {"transition":"slide","transitionSpeed":"slow","controls":true,"progress":true,"slideNumber":"c/t","hash":true,"previewLinks":true,"_":["scripts/"],"static":"docs","static-dirs":"scripts/01_Programmieren_Vorlesung/img,scripts/02_SoftwareCraftsmanship/img,scripts/pdfdownloads,scripts/03_OtherStuff/img","staticDirs":"scripts/01_Programmieren_Vorlesung/img,scripts/02_SoftwareCraftsmanship/img,scripts/pdfdownloads,scripts/03_OtherStuff/img","css":"scripts/_assets/style.css"}, queryOptions);
    </script>

    <script src="./../_assets/lib/mermaid.min.js"></script>
    <script src="./../_assets/lib/reveal-mermaid.js"></script>

    <script>
      Reveal.initialize(options);
      Reveal.addEventListener('ready', function (event) {
        const blocks = Reveal.getRevealElement().querySelectorAll('pre code:not(.mermaid)');
        const hlp = Reveal.getPlugin('highlight');
        blocks.forEach(hlp.highlightBlock);
      });
    </script>

    <script>
      const mermaidOptions = extend({ startOnLoad: false }, {});
      mermaid.startOnLoad = false;
      mermaid.initialize(mermaidOptions);
      const cb = function (event) {
        mermaid.init(mermaidOptions, '.stack.present > .present pre code.mermaid');
        mermaid.init(mermaidOptions, '.slides > .present:not(.stack) pre code.mermaid');
      }
      Reveal.addEventListener('ready', cb);
      Reveal.addEventListener('slidetransitionend', cb);
    </script>
  </body>
</html>
